// ------------------------------------------------------------------------------
//  <autogenerated>
//      This code was generated by a tool.
//      Mono Runtime Version: 4.0.30319.1
// 
//      Changes to this file may cause incorrect behavior and will be lost if 
//      the code is regenerated.
//  </autogenerated>
// ------------------------------------------------------------------------------
using System;
using UnityEngine;
using System.Collections;
using Molecule.Model;
using System.Collections.Generic;
using UI;
using Molecule.Control;
using OptimalView;

namespace Reorient
{
		public class Reorient
		{
			public static void LoadSymmetry(float Xorigin, float Yorigin, float Zorigin, float Xdirection, float Ydirection, float Zdirection)
			{
				Debug.Log (MoleculeModel.atomsLocationlist[0][0]+" "+MoleculeModel.atomsLocationlist[0][1]+" "+MoleculeModel.atomsLocationlist[0][2]);
				Debug.Log("REORIENTATION");
				//Vector3 origin = new Vector3 (Xorigin, Yorigin, Zorigin);
				Vector3 direction = new Vector3 (Xdirection, Ydirection, Zdirection);
				direction.Normalize ();
				//float[] position= MoleculeModel.atomsLocationlist[0] as float[];
				// Re-orientation of pdb coordinates to be oriented according to the symmetry axis
				//Vector3 orientation = direction;
				//axis = self.symmetry_axes[0].direction
				float angle = Vector3.Angle(direction, -Vector3.up);
				Vector3 rot_axis = Vector3.Cross (direction, -Vector3.up);
				Debug.Log ("Axis: "+rot_axis);
				Debug.Log ("Angle: "+angle);
				Quaternion rotate = Quaternion.AngleAxis (angle, rot_axis);
//				Vector3 test = new Vector3 (2.0f, 2.0f, 2.0f);
//				Vector3 result = rotate * test;
//				Debug.Log ("Result: "+result);
				for (int i=0; i<MoleculeModel.atomsLocationlist.Count; i++) {
					float[] position= MoleculeModel.atomsLocationlist[i] as float[];
					Vector3 vec_pos = new Vector3(position[0], position[1], position[2]);
					Vector3 new_vec = rotate * vec_pos;
					position[0] = new_vec.x;
					position[1] = new_vec.y;
					position[2] = new_vec.z;
					MoleculeModel.atomsLocationlist[i] = position;
				}
				Debug.Log (MoleculeModel.MinValue);
				ControlMolecule.BuildMoleculeComponents ();
				Debug.Log (MoleculeModel.MinValue);
				// Switch on the guided navigation mode
				UIData.guided = true;
				UIData.resetDisplay = true;
				UIData.resetBondDisplay = true;
				UIData.isCubeToSphere = true;
				UIData.isSphereToCube = false;
				UIData.atomtype = UIData.AtomType.sphere;
				BallUpdate.resetColors = true;

//				BallUpdate.resetRadii = true;
				MoleculeModel.newtooltip = GUI.tooltip;
				
				Debug.Log("resname length: "+MoleculeModel.atomsResnamelist.Count);
				Debug.Log("atomtype length: "+MoleculeModel.atomsTypelist.Count);
				Debug.Log("resname length: "+MoleculeModel.atomsChainList.Count);
				Debug.Log("resname length: "+MoleculeModel.atoms.Count);
				
				float x_tot = 0.0f;
				float y_tot = 0.0f;
				float z_tot = 0.0f;
				int count = 0;
				
				for (int i=0; i<MoleculeModel.atomsLocationlist.Count; i++) {
					if(MoleculeModel.atomsChainList[i] == "B" && MoleculeModel.residueIds[i] == 194){
						float[] position= MoleculeModel.atomsLocationlist[i] as float[];
						x_tot += position[0];
						y_tot += position[1];
						z_tot += position[2];
						count++;
					}
				}
				float[] target = new float[3];
				target[0] = x_tot/count;
				target[1] = y_tot/count;
				target[2] = z_tot/count;
			
				Debug.Log ("Target coordinates: "+x_tot/count+" "+y_tot/count+" "+z_tot/count);
//				float[] target= MoleculeModel.atomsLocationlist[0] as float[];
				//OptimalView.OptimalView.GetOptimalPosition(target, (float) 15.0);

			//Refilling CA list for CA trace and BF representation

			List<float[]> calist = new List<float[]>();

			for (int i = 0; i<MoleculeModel.atomsNamelist.Count; i++){
				if(MoleculeModel.atomsNamelist[i] == "CA"){
					float[] vect = new float[3];
					vect[0] = MoleculeModel.atomsLocationlist[i][0];
					vect[1] = MoleculeModel.atomsLocationlist[i][1];
					vect[2] = MoleculeModel.atomsLocationlist[i][2];
					calist.Add (vect);
				}
			}

			MoleculeModel.CatomsLocationlist = calist;
			MoleculeModel.backupCatomsLocationlist = calist;

			// Refilling residuedictionaries for Ribbons

			List<Dictionary<string, Vector3>>   residueDictList     =   new List<Dictionary<string, Vector3>>();
			Dictionary<string, Vector3>			residueDict			=	new Dictionary<string, Vector3>();
			List<int>							residueIds			=	MoleculeModel.residueIds;
			Vector3 testVector = Vector3.zero;

			int currResId = int.MinValue+1;
			int prevResId = int.MinValue+1;

			for (int i = 0; i<MoleculeModel.atomsNamelist.Count; i++) {

				currResId = residueIds[i];
				Vector3 currAtom = new Vector3(MoleculeModel.atomsLocationlist[i][0], MoleculeModel.atomsLocationlist[i][1], MoleculeModel.atomsLocationlist[i][2]);

				if(currResId != prevResId) {
					if(residueDict != null && residueDict.Count > 0){
						residueDictList.Add(residueDict);
					}
					residueDict = new Dictionary<string, Vector3>();
				}
				prevResId = currResId;
				if(!residueDict.TryGetValue(MoleculeModel.atomsNamelist[i], out testVector)){
					residueDict.Add(MoleculeModel.atomsNamelist[i], currAtom);}
				
			}

			MoleculeModel.residueDictionaries = residueDictList;

			CreateAxeAndOrigin();
		} // End of LoadSymmetry

//						rot_axis = axis ^ Vector3D(0.0, 1.0, 0.0)
//						axis = [rot_axis.x, rot_axis.y, rot_axis.z]
//						pymol.cmd.rotate(axis, angle)
//						self.symmetry_axes[0].direction = Vector3D(0.0, 1.0, 0.0)
//						self.symmetry_axes[0].origin = [0.0, 0.0, 0.0]

		public static void CreateAxeAndOrigin(){
			GameObject originPoint = GameObject.CreatePrimitive (PrimitiveType.Sphere);
			originPoint.transform.position = new Vector3 (0, 1, 0);
			originPoint.transform.localScale = new Vector3 (4, 4, 4);
			originPoint.tag = "Origin";

			GameObject symAxe = GameObject.CreatePrimitive (PrimitiveType.Cylinder);
			symAxe.transform.position = new Vector3 (0, 1, 0);
			symAxe.transform.localScale = new Vector3 (1, (MoleculeModel.MaxValue.y - MoleculeModel.MinValue.y), 1);
			symAxe.tag = "Origin";
			symAxe.GetComponent<Renderer>().material.color = Color.red;
		}

	}	
		
}

